declare const lx: lxr.LxCustomReportLib;
declare module lxr
{
	/**
	 * Entry class of the LeanIX Reporting Library.
	 * An instance of this class is globally available as `lx` variable.
	 *
	 * The sequence to initialise the library for a report looks like this:
	 * ```js
	 * lx.init()
	 * .then(function (setupInfo) {
	 *   // Process setupInfo and create config object
	 *   var config = {};
	 *  lx.ready(config);
	 * });
	 * ```
	 */
	export class LxCustomReportLib {
	    filter: ReportLibFilter;
	    table: ReportLibTable;
	    readonly latestPublishedState: any;
	    readonly dataModelHelpers: DataModelHelpers;
	    private messenger;
	    private currentSetup;
	    private latestFacetsResults;
	    private _latestPublishedState;
	    private customDropdownCallbacks;
	    constructor();
	    /**
	     * Starts initialisation of the reporting framework. Returns a promise
	     * which is resolved once initialisation with the framework is finished. The
	     * resolved promise contains a [[ReportSetup]] instance with information
	     * provided to you through the framework.
	     * With that information you should be able to setup your report properly. Once
	     * that is done the [[LxCustomReportLib.ready]] function should be called to signal
	     * that the report is ready to receive and process data and user events.
	     */
	    init(): Promise<ReportSetup>;
	    /**
	     * Signals that the custom report is ready. A configuration must be provided
	     * to tell the framework about the requirements of the report (most importantly which data it needs).
	     * The provided configuration acts as an interface between the report code
	     * and the report framework.
	     *
	     * @param {ReportConfiguration} configuration
	     */
	    ready(configuration: ReportConfiguration): void;
	    /**
	     * In case the report has new requirements towards the report framework it can
	     * update the configuration that was initially passed to [[LxCustomReportLib.ready]].
	     *
	     * @param {ReportConfiguration} configuration
	     */
	    updateConfiguration(configuration: ReportConfiguration): void;
	    /**
	     * Execute a custom GraphQL query to the LeanIX GraphQL API.
	     *
	     * @param  {string}              query GraphQL query
	     * @return {PromiseLike<any>}          A promise that resolves to the resulting data
	     * @example
	     * ```js
	     * lx.executeGraphQL(`{
	     *  allFactSheets(factSheetType: ITComponent) {
	     *    edges {
	     *      node {
	     *        id
	     *        name
	     *        type
	     *        description
	     *      }
	     *    }
	     *  }
	     * }`)
	  
	     * ```
	     */
	    executeGraphQL(query: string, variables?: string | any): Promise<any>;
	    /**
	     * Allows to make a XHR requests through the parents origin.
	     */
	    executeParentOriginXHR(method: string, path: string): Promise<any>;
	    /**
	     * Returns the current filter result.
	     */
	    getFilterResult(): any[];
	    /**
	     * Request the report framework to show a dialog to the user,
	     * so that he/she can select one or more Fact Sheets.
	     *
	     * @param  {FactSheetSelectionConfig} config Configures the Fact Sheet selection.
	     * @return {PromiseLike<any[]>}              A promise that resolves to the selected Fact Sheets
	     */
	    requestFactSheetSelection(config: FactSheetSelectionConfig): Promise<any[]>;
	    /**
	     * Since reports run inside an iframe, they are not allowed to open links.
	     * This function allows you to open a link just like it would be opened outside
	     * of the iframe.
	     *
	     * It will trigger window.open() with the provided url and target, see:
	     * https://developer.mozilla.org/en-US/docs/Web/API/Window/open
	     *
	     * @example
	     * ```js
	     * lx.openLink('/factsheets/Application/123-456', '_blank');
	     * ```
	     */
	    openLink(url: string, target?: string): void;
	    openRouterLink(url: string): void;
	    /**
	     * In case the report has some sort of internal state it should be published
	     * to the framework. The state will be persisted when the user saves a certain
	     * report configuration. Once that report configuration is restored the framework
	     * will pass the saved state to the report on initialisation
	     * ([[LxCustomReportLib.init]] and [[ReportSetup.savedState]])
	     */
	    publishState(state: any): void;
	    /**
	     * Tells the framework to show a spinner on top of the report.
	     * In order to hide the spinner call [[LxCustomReportLib.hideSpinner]]
	     *
	     * @param {string} [text='']
	     */
	    showSpinner(text?: string): void;
	    /**
	     * Tells the framework to hide a spinner
	     * that was previously shown via [[LxCustomReportLib.showSpinner]]
	     */
	    hideSpinner(): void;
	    showEditToggle(): void;
	    hideEditToggle(): void;
	    sendExcludedFactSheets(excludedData: any[]): void;
	    /**
	     * Returns the translation of custom translation key according to the users current language.
	     * If the translation key can be resolved to a translated string interpolation will be applied.
	     * If the translation key resolves to a object the object will be returned.
	     *
	     * Example
	     * Given the following custom translation json
	     * {
	     *   "header": {
	     *     "title": "The title",
	     *     "subtitle": "Subtitle"
	     *   }
	     * }
	     *
	     * lx.translateCustomKey('header.title') => Returns 'The title'
	     * lx.translateCustomKey('header') => Returns { "title": "The title", "subtitle": "Subtitle" }
	     */
	    translateCustomKey(key: string, interpolationData?: any): string | any;
	    translateFactSheetType(fsType: string, multiplicity?: 'singular' | 'plural'): string;
	    translateField(fsType: string, fieldName: string): string;
	    translateFieldValue(fsType: string, fieldName: string, value: string): string;
	    translateRelation(directionalRelationName: string): string;
	    formatCurrency(value: number, minimumFractionDigits?: number): string;
	    private createReportRequirements(config);
	    private mountCallbacks(config);
	    private mountFacetsCallbacks(facetsConfig, index);
	    private mountFacetsResultCallback(facetsConfigKey, cb);
	    private validateConfig(config);
	    private mountSetupCallback();
	    private mountRestoreCallback(config);
	    private mountCustomDropdownSelectionCallbacks(config);
	    private mountExportDataCallback(config);
	    private mountTableConfigCallback(config);
	    private mountCallback(config, messageId, callbackName);
	    private getLocationQuery();
	    private createReportExportData(reportConfig);
	    private getCurrentStyles();
	    private encodeAllImages(el, inputType);
	    private encodeImage(image);
	    private encodeSvgImage(image);
	    private translateHtmlTags();
	    private replaceInterpolations(text, data?);
	    private mountDomEventPublishing();
	}
	export const lxCustomReportLib: LxCustomReportLib;

	/**
	 * This file contains pure functions that work on the dataModel or enrichedDataModel.
	 * This file is also included in the report library, so it must not include any service.
	 *
	 * !!!!!!
	 *
	 * POTENTIONALLY USED IN REPORTS, DO NOT SIMPLY ALTER!!!!
	 *
	 * !!!!!!
	 */
	export class DataModelHelpers {
	    getRelationDefinition(enrichedDataModel: EnrichedDataModel, directionalRelation: string): RelationDataModel;
	    isConstrainingRelation(enrichedDataModel: EnrichedDataModel, relationName: string): boolean;
	}

	/** Interface for enriched data model */
	export interface EnrichedDataModel extends BaseDataModel {
	    factSheets: {
	        [key: string]: EnrichedFactSheetDataModel;
	    };
	    relationMapping: {
	        [key: string]: RelationMappingDataModel;
	    };
	}
	export const DEFAULT_FACT_SHEET_TYPES: ReadonlyArray<string>;

	export interface BaseDataModel {
	    factSheets: {
	        [key: string]: FactSheetDataModel | EnrichedFactSheetDataModel;
	    };
	    relations: {
	        [key: string]: RelationDataModel;
	    };
	    externalIdFields: any;
	    rules: any;
	    validators: any;
	}
	export interface DataModel extends BaseDataModel {
	    factSheets: {
	        [key: string]: FactSheetDataModel;
	    };
	}

	/**
	 * Contains information about a field from the data model.
	 */
	export interface DataModelField {
	    fieldName: string;
	    factSheetType: string;
	    definition: DataModelFieldDefinition;
	}
	export interface BaseFieldDefinition {
	    type: DataModelFieldType;
	    mandatory?: boolean;
	    quickSearch?: boolean;
	    fullTextSearch?: boolean;
	    inFacet?: boolean;
	    inView?: boolean;
	}
	export interface DoubleFieldDefinition extends BaseFieldDefinition {
	    type: 'DOUBLE';
	}
	export interface ExternalIdFieldDefinition extends BaseFieldDefinition {
	    type: 'EXTERNAL_ID';
	    urlTemplate?: String;
	    uniqueFactSheet?: boolean;
	    autoIncrement?: boolean;
	    readOnly?: boolean;
	    validators?: string[];
	    inFacet?: undefined;
	    inView?: undefined;
	}
	export interface IntegerFieldDefinition extends BaseFieldDefinition {
	    type: 'INTEGER';
	}
	export interface LifecycleFieldDefinition extends BaseFieldDefinition {
	    type: 'LIFECYCLE';
	    values?: string[];
	}
	export interface LocationFieldDefinition extends BaseFieldDefinition {
	    type: 'LOCATION';
	}
	export interface MultipleSelectFieldDefinition extends BaseFieldDefinition {
	    type: 'MULTIPLE_SELECT';
	    values?: string[];
	}
	export interface ProjectStatusFieldDefinition extends BaseFieldDefinition {
	    type: 'PROJECT_STATUS';
	    values?: string[];
	}
	export interface SingleSelectFieldDefinition extends BaseFieldDefinition {
	    type: 'SINGLE_SELECT';
	    values?: string[];
	}
	export interface StringFieldDefinition extends BaseFieldDefinition {
	    type: 'STRING';
	    validators?: string[];
	}
	export interface StringFieldDefinition extends BaseFieldDefinition {
	    type: 'STRING';
	    validators?: string[];
	}
	export interface AggegatedFieldDefinition extends BaseFieldDefinition {
	    type: 'AGGREGATED';
	    mandatory?: undefined;
	    quickSearch?: undefined;
	    fullTextSearch?: undefined;
	    inFacet?: undefined;
	    inView?: undefined;
	    paths?: [{
	        path: string;
	    }];
	    function?: 'SUM' | 'AVG' | 'MIN' | 'MAX' | 'COUNT' | 'ITC_CRITICAL_COUNT' | 'ITC_ABS_COUNT' | 'ITC_CRITICAL_RATIO';
	}
	export interface FrontEndBaseFieldDefinition extends BaseFieldDefinition {
	    mandatory?: undefined;
	    quickSearch?: undefined;
	    fullTextSearch?: undefined;
	    inFacet?: undefined;
	    inView?: undefined;
	}
	export interface RelationFieldDefinition extends FrontEndBaseFieldDefinition {
	    type: 'RELATION';
	    relationDefinition: RelationDataModel;
	}
	export interface TagsFieldDefinition extends FrontEndBaseFieldDefinition {
	    type: 'TAGS';
	}
	export interface SubscriptionsFieldDefinition extends FrontEndBaseFieldDefinition {
	    type: 'SUBSCRIPTIONS';
	}
	export interface DateTimeFieldDefinition extends FrontEndBaseFieldDefinition {
	    type: 'DATE_TIME';
	}
	export interface CompletionFieldDefinition extends FrontEndBaseFieldDefinition {
	    type: 'COMPLETION';
	}
	export interface QualitySealStatusFieldDefinition extends FrontEndBaseFieldDefinition {
	    type: 'QUALITYSEALSTATUS';
	}
	export type DataModelFieldDefinition = DoubleFieldDefinition | ExternalIdFieldDefinition | IntegerFieldDefinition | LifecycleFieldDefinition | LocationFieldDefinition | MultipleSelectFieldDefinition | ProjectStatusFieldDefinition | SingleSelectFieldDefinition | StringFieldDefinition | AggegatedFieldDefinition | RelationFieldDefinition | TagsFieldDefinition | SubscriptionsFieldDefinition | DateTimeFieldDefinition | CompletionFieldDefinition | QualitySealStatusFieldDefinition;
	export interface DataModelFieldsDefinition {
	    [fieldName: string]: DataModelFieldDefinition;
	}
	export type TimeUnit = 'SECONDS' | 'MINUTES' | 'HOURS' | 'DAYS';
	export class QualitySealConfig {
	    enabled: boolean;
	    value: number;
	    unit: TimeUnit;
	}
	export interface FactSheetConfig {
	    qualitySeal?: QualitySealConfig;
	    maxHierarchyLevel?: number;
	}
	/** Fact Sheet definition in basic (non-enriched) data model */
	export interface FactSheetDataModel {
	    fields: DataModelFieldsDefinition;
	    config: FactSheetConfig;
	    namingRule: any;
	}
	/** Fact Sheet definition in enriched data model */
	export interface EnrichedFactSheetDataModel {
	    fields: DataModelFieldsDefinition;
	    relations: string[];
	    config: FactSheetConfig;
	    namingRule?: any;
	}

	export interface DirectionalRelationDataModel {
	    name: string;
	    factSheetType: string;
	    multiplicity: string;
	    groupByTargetField?: string;
	    mandatory?: boolean;
	}
	export interface RelationDataModel {
	    from: DirectionalRelationDataModel;
	    to: DirectionalRelationDataModel;
	    constraints: RelationConstraint[];
	    fields: {
	        [fieldName: string]: any;
	    };
	    constrainingRelations?: string[];
	}
	export type RelationConstraint = 'TYPE_EQUAL' | 'CYCLES_ALLOWED' | 'FACT_SHEET_UNIQUE_LAX';

	export type DataModelFieldType = 'DOUBLE' | 'INTEGER' | 'LIFECYCLE' | 'LOCATION' | 'MULTIPLE_SELECT' | 'SINGLE_SELECT' | 'STRING' | 'EXTERNAL_ID' | 'PROJECT_STATUS' | 'AGGREGATED' | 'RELATION' | 'TAGS' | 'SUBSCRIPTIONS' | 'DATE_TIME' | 'COMPLETION' | 'QUALITYSEALSTATUS';

	export interface RelationMappingDataModel {
	    direction: string;
	    reverseName: string;
	    persistedName: string;
	}

	export type DefaultFactSheetType = 'Default';

	export type PaperOrientation = 'portrait' | 'landscape';
	export interface ExportData {
	    name: string;
	    inputType: string;
	    outputType: string;
	    autoScale: boolean;
	    data: string;
	    paperSize: PaperSize;
	    styles: string;
	    options?: string;
	    scale?: string;
	    viewportSize: ViewportSize;
	    zoomFactor: number;
	}
	export interface PaperSize {
	    dimension: string;
	    format: string;
	    orientation: PaperOrientation;
	    margin: string;
	    footer: MarginObject;
	    header: MarginObject;
	}
	export interface MarginObject {
	    contents: string;
	    height: string;
	    images: string[];
	    logoImageSrc?: string;
	}
	export interface ViewportSize {
	    height: number;
	    width: number;
	}
	export interface ExportResponse {
	    extension: string;
	    fileName: string;
	    id: string;
	    relativeUrl: string;
	}
	export interface PaperType {
	    id: string;
	    name: string;
	    width: number;
	    height: number;
	}
	export interface ExportInitialData {
	    title?: string;
	    data: string;
	    styles: string;
	    fileNameSuffix?: string;
	    inputType: string;
	    paperSize: {
	        format: string;
	    };
	    orientation: PaperOrientation;
	    autoScale: boolean;
	    viewLegendData?: {
	        html: string;
	        styles: string;
	    };
	}

	export interface ReportSetupSettings {
	    baseUrl?: string;
	    environment?: Environment;
	    viewModel?: ViewModel;
	    dataModel?: EnrichedDataModel;
	    translations?: ReportSetupTranslations;
	    currency?: ReportSetupCurrency;
	}
	export interface ReportSetupConfig {
	    factSheetType?: string;
	    [others: string]: any;
	}
	export interface ReportSetup {
	    reportId: string;
	    config: ReportSetupConfig;
	    settings: ReportSetupSettings;
	    savedState?: ReportingBookmarkState;
	}
	export interface ReportSetupTranslations {
	    factSheetTypes: {
	        [key: string]: string;
	    };
	    relations: {
	        [relationName: string]: RelationTranslation;
	    };
	    fields: {
	        [factSheetType: string]: {
	            [fieldName: string]: {
	                label: string;
	                values: {
	                    [value: string]: {
	                        label: string;
	                    };
	                };
	            };
	        };
	    };
	    /**
	     * The reports custom translation for the current language.
	     */
	    custom: {
	        label: string;
	        [customKeys: string]: any;
	    };
	}
	export interface RelationTranslation {
	    label: string;
	    values: {
	        [value: string]: string;
	    };
	}
	export interface ReportSetupCurrency {
	    code: string;
	    symbol: string;
	}

	export class ReportingBookmarkState {
	    filters: {
	        [key: string]: BookmarkFilter;
	    };
	    views: {
	        [context: string]: {
	            activeViewKey?: string;
	            factSheetType?: string;
	            viewOption?: ReportViewOption;
	        };
	    };
	    customState?: any;
	    customDropdownSelections?: {
	        [dropdownId: string]: string;
	    };
	}

	export type ViewConstraintType = 'MAPPING_PER_YEAR';
	export interface ReportViewOption {
	    constraint?: ViewConstraintType;
	    constrainingRelation?: string[];
	    startDate?: string;
	    endDate?: string;
	}

	export interface BookmarkFilter {
	    /**
	     *  The FactSheet type can be get and set with:
	     *  - FacetsService.getSelectedFactSheetTypeFromFilters(facetFilter)
	     *  - FacetsService.updateFactSheetTypeInFilters(facetFilter, newFactSheetType)
	     */
	    facetFilter: FacetFilter[];
	    fullTextSearchTerm?: string;
	    factSheetIds?: string[];
	    sorting?: Sorting[];
	}

	export type SortingMode = 'BY_FIELD' | 'BY_LIFECYCLE_LAST_PHASE';
	export type SortingOrder = 'asc' | 'desc';
	export class Sorting {
	    mode?: SortingMode;
	    key: string;
	    order: SortingOrder;
	}

	export class FacetFilter {
	    facetKey: string;
	    keys: string[];
	    operator?: string;
	    dateFilter?: DateFilter;
	    subscriptionFilter?: SubscriptionFilterInput;
	    subFilter?: {
	        facetFilters: FacetFilter[];
	        fullTextSearch?: string;
	        ids?: string[];
	    };
	}

	export type DateFilterType = 'POINT' | 'RANGE' | 'TODAY' | 'END_OF_MONTH' | 'END_OF_YEAR';
	export interface DateFilter {
	    type: DateFilterType;
	    minDate?: string;
	    maxDate?: string;
	    from?: string;
	    to?: string;
	}

	export interface SubscriptionFilterInput {
	    type: SubscriptionType;
	    roleId?: string;
	}

	export type SubscriptionType = 'RESPONSIBLE' | 'OBSERVER' | 'ACCOUNTABLE' | 'ALL';

	export interface ViewModel {
	    layouts: any;
	    factSheets: FactSheetViewModel[];
	}

	export type FieldType = 'text' | 'number' | 'externalId' | 'textarea' | 'multipleSelect' | 'status' | 'costs' | 'lifecycle' | 'location' | 'date' | 'percentage';
	export interface StatusIcon {
	    type: string;
	    color?: string;
	    reverse?: boolean;
	}
	export interface Field<T = FieldType> {
	    name: string;
	    type: T;
	    size?: number;
	    options?: any;
	}
	export interface Layout<T = FieldType> {
	    fields: Field<T>[];
	}
	export interface TemplateOptionsBase<T = FieldType> {
	    layout?: Layout<T>;
	}
	export interface TemplateOptionsRelation extends TemplateOptionsBase {
	    relationName: string;
	    /**
	     * Optional list of tags for filtering which new & existing Fact Sheets are permitted for this relation.
	     * For now only implemented on front-end for Survey.
	     */
	    tagFilter?: string[];
	}
	export interface TemplateOptionsConnection extends TemplateOptionsBase {
	    connectionName: string;
	}
	export type TemplateOptions<T = FieldType> = TemplateOptionsBase<T> | TemplateOptionsRelation;
	export function isViewModelTemplateOptionsRelation(templateOptions: TemplateOptions): templateOptions is TemplateOptionsRelation;
	export function isViewModelTemplateOptionsConnection(templateOptions: TemplateOptions): templateOptions is TemplateOptionsConnection;
	export type FactSheetViewModelTemplateType = 'fields' | 'relation' | 'projectStatus';
	export interface FactSheetViewModelSubsection<T = FieldType> {
	    label: string;
	    helpText?: string;
	    template: FactSheetViewModelTemplateType;
	    templateOptions?: TemplateOptions<T>;
	    weight?: number;
	    disabled?: boolean;
	}
	export interface ViewModelSingleFieldValueMetaData {
	    bgColor?: string;
	    color?: string;
	    /** icons, e.g: ['fa-star', 'fa-star'] */
	    icon?: string[];
	    iconColors?: string[];
	}
	export interface ViewModelSingleFieldMetaData {
	    icon?: StatusIcon;
	    values: {
	        [value: string]: ViewModelSingleFieldValueMetaData;
	    };
	}
	export interface ViewModelRelationMetaData {
	    [fieldName: string]: ViewModelSingleFieldMetaData;
	}
	export interface ViewModelFieldMetaData {
	    [fieldName: string]: ViewModelSingleFieldMetaData | ViewModelRelationMetaData;
	}
	export type FactSheetViewModelSectionTabs = 'default' | 'subscriptions';
	export interface FactSheetViewModelSection<T = FieldType> {
	    label: string;
	    subsections: FactSheetViewModelSubsection<T>[];
	    weight?: number;
	    disabled?: boolean;
	    tabs?: FactSheetViewModelSectionTabs[];
	}
	export interface HoverConfigViewField {
	    name: string;
	    type: string;
	}
	export interface HoverConfigViewModel {
	    fields: HoverConfigViewField[];
	}
	export class FactSheetViewModel<T = FieldType> {
	    type: string;
	    bgColor: string;
	    color: string;
	    fieldMetaData?: ViewModelFieldMetaData;
	    sections: FactSheetViewModelSection<T>[];
	    weight?: number;
	    onTheFlyCreation?: boolean;
	    hoverConfig?: HoverConfigViewModel;
	}

	export type EnvironmentName = 'prod' | 'dev' | 'test';
	export interface Environment {
	    readonly name: EnvironmentName;
	    wasToggledTo: EnvironmentName;
	    production: boolean;
	    showUnfinished: boolean;
	    devTools: boolean;
	    version: string;
	    build: string;
	}

	export interface FactSheetSelectionConfig {
	    /**
	     * Should it be possible to select one Fact Sheet or several Fact Sheets?
	     */
	    mode: 'SINGLE' | 'MULTIPLE';
	    /**
	     * Attributes of each Fact Sheet to be returned
	     *
	     * @type {string[]}
	     */
	    attributes: string[];
	    /**
	     * Restrict selection possibilities to this Fact Sheet type.
	     */
	    factSheetType?: string;
	}

	/**
	 * Configures the reporting table for the report.
	 * It allows to specify the initial attributes
	 * that should be displayed in the table.
	 *
	 * Example:
	 * factSheetType: 'Application',
	 * attributes: ['release', 'alias'],
	 * relatedFactSheetTypes: {
	 *    BusinessCapability: 'relApplicationToBusinessCapability',
	 *    UserGroup: 'relApplicationToUserGroup'
	 * }
	 */
	export interface ReportTableConfig {
	    factSheetType: string;
	    attributes: (string | ReportTableColumn)[];
	    /**
	     * Maps Fact Sheet type to relation type in order to
	     * add them as subfilter in table view.
	     */
	    relatedFactSheetTypes?: {
	        [facetsConfigKey: string]: string;
	    };
	}
	export interface ReportTableColumn {
	    key: string;
	    label: string;
	    type: DataModelFieldType;
	    sortable?: boolean;
	    align?: TableColumnAlign;
	    isCustomColumn?: boolean;
	    virtualKey?: string;
	}
	/**
	 * Represents one selectable entry.
	 */
	export interface CustomDropdownEntry {
	    id: string;
	    name: string;
	    /**
	     * This callback is invoked once the user selects the corresponding entry.
	     */
	    callback: (currentEntry: CustomDropdownEntry) => void;
	}
	/**
	 * Represents a custom dropdown menu with several entries.
	 */
	export interface CustomDropdown {
	    id: string;
	    name: string;
	    entries: CustomDropdownEntry[];
	    initialSelectionEntryId?: string;
	}
	/**
	 * Describes the available configuration options for a report.
	 */
	export interface ReportConfiguration {
	    /**
	     * Multiple facets configurations ([[ReportFacetsConfig]]) can be provided
	     * in order to allow the user to filter different aspects of your report.
	     */
	    facets?: ReportFacetsConfig[];
	    menuActions?: {
	        /**
	         * Does the report provide configuration possibilities.
	         * If true: There will be a configuration action shown to the user,
	         *      that triggers [[ReportConfiguration.configureCallback]].
	         *
	         * Default: false.
	         */
	        showConfigure?: boolean;
	        /**
	         * This callback is invoked whenever the user wants to see / change
	         * the reports configuration.
	         */
	        configureCallback?: () => void;
	        /**
	         * Define custom dropdowns that are shown to the user and allow him or her
	         * to select different options that influcene how the report behaves or
	         * presents data.
	         */
	        customDropdowns?: CustomDropdown[];
	    };
	    /**
	     *
	     * This callback is invoked whenever the user changes the view of the report.
	     * It is also invoked, once the report view results are loaded during
	     * initialization.
	     */
	    reportViewCallback?: (view: any) => void;
	    /**
	     * Additional options that can be provided for the view calculation.
	     */
	    reportViewOption?: ReportViewOption;
	    /**
	     * This callback is invoked whenever a saved state should be restored.
	     */
	    restoreStateCallback?: (state) => void;
	    /**
	     * Defines whether the reporting framework should allow the user to switch
	     * into a table view that shows the data of the report.
	     * If not specified the default value is `true`, so the table view will be
	     * allowed if not explicitly disabled.
	     *
	     * Hint: In order to configure the table (e.g. initially visible columns)
	     * for the report use [[ReportConfiguration.tableConfigCallback]]
	     */
	    allowTableView?: boolean;
	    /**
	     * This callback is invoked whenever the user switches to the table config mode.
	     * It should provide a reasonable default for the initial configuration of the table.
	     */
	    tableConfigCallback?: () => ReportTableConfig;
	    /**
	     * Specifiy whether the user shall be able to edit the report.
	     * If the user toggles the editing mode the reporting framework
	     * calls [[ReportConfiguration.toggleEditingCallback]] to inform
	     * you about enabled or disabled edit mode.
	     */
	    allowEditing?: boolean;
	    /**
	     * This callback is invoked whenever the user enables or disables editing.
	     * The action to enable or disable editing is only visible when [[ReportConfiguration.allowEditing]]
	     * is set to true.
	     */
	    toggleEditingCallback?: (editingEnabled: boolean) => void;
	    /**
	     * The export options allow to influence the PDF or image export of a report.
	     */
	    export?: {
	        /**
	         * CSS selector which specifies the DOM element whoes contents should be
	         * extracted for export to PDF or image.
	         */
	        exportElementSelector?: string;
	        /**
	         * Which type of content is extracted from DOM and used
	         * to be exported. Default is HTML.
	         *
	         * Specify SVG if your report uses svg elements for visualization.
	         */
	        inputType?: 'HTML' | 'SVG';
	        /**
	         * Default = true
	         */
	        autoScale?: boolean;
	        /**
	         * Default = 'a4'
	         */
	        format?: 'a0' | 'a1' | 'a2' | 'a3' | 'a4' | 'letter';
	        /**
	         * Default = 'portrait'
	         */
	        orientation?: 'portrait' | 'landscape';
	        /**
	         * This callback is invoked just before the report framework extracts the HTML
	         * from the report to export it as PDF or image. It allows to make adjustments
	         * to the HTML for exporting.
	         */
	        beforeExport?: (exportElement: JQuery) => JQuery;
	    };
	}

	export type TableColumnAlign = 'LEFT' | 'RIGHT' | 'CENTER' | 'JUSTIFY';

	/**
	 * Contains the configurations required
	 * to filter on a specific portion of the reports data.
	 */
	export interface ReportFacetsConfig {
	    key: string;
	    callback?: (data: any[]) => void;
	    label?: string;
	    fixedFactSheetType?: string;
	    /**
	     * The Fact Sheet attributes that should be queried from the backend.
	     * Example: `attributes: ['type', 'displayName']`
	     *
	     * Complex attributes need a subquery: `attributes: ['tags { }']
	     */
	    attributes?: string[];
	    sortings?: Sorting[];
	    defaultPageSize?: number;
	    /**
	     * If defined these filters will be applied as initial default
	     * when the user enters the report.
	     */
	    defaultFilters?: FacetFilter[];
	    facetChangedCallback?: (facet: any) => void;
	    facetFiltersChangedCallback?: (data: ReportFacetsCallbackData) => void;
	}
	export interface ReportFacetsCallbackData {
	    facets: FacetFilter[];
	    directHits: DirectHit[];
	    fullTextSearchTerm?: string;
	}

	export interface DirectHit {
	    id: string;
	    displayName: string;
	}

	/**
	 * ReportRequirements are sent from the custom report via report-lib
	 * to the reporting container. They specify which requirements
	 * the report has regarding the reporting environment. These are
	 * things like: requires facets, or requires a view.
	 */
	export interface ReportRequirements extends ReportConfiguration {
	    showView?: boolean;
	}

	export class ReportLibFilter {
	    private messenger;
	    getSelectedFilters(): Promise<FacetGroup[]>;
	}

	/** Valid GraphQL FacetType; constants defined in facets.const.ts */
	export type BackendFacetType = 'SIMPLE' | 'TAG' | 'FACTSHEETTYPE' | 'RELATION' | 'LIFECYCLE' | 'SUBSCRIPTIONS' | 'EXTERNAL_ID' | 'HIERARCHY';
	/** Pseudo-FacetTypes implemented only in front-end; constants defined in facets.const.ts */
	export type FrontendFacetType = 'FACT_SHEET_ID' | 'FULLTEXTSEARCH' | 'SINGLE_SELECT' | 'UNKNOWN' | 'AGGREGATION';
	export type FacetType = BackendFacetType | FrontendFacetType;
	export interface FacetGroup {
	    /**
	     * Key of the facet.
	     */
	    facetKey: string;
	    /**
	     * The logical operation that is set for this facet.
	     */
	    operator: string;
	    /**
	     * List of operators the backend supports for this facet.
	     */
	    possibleOperators?: string[];
	    /**
	     * The type of the facet results.
	     * Depending on the type of the results the facet is rendered differently.
	     * 'UNKNOWN' is set when the information from the BE is missing, for example
	     * when the Facet is generated on the fly (in the Bookmarks)
	     */
	    facetType: FacetType;
	    /**
	     * Might contain additional information depending on the 'facetType'
	     */
	    facetSubType?: string;
	    /**
	     * List of available entries.
	     */
	    results: FacetListEntry[];
	    /**
	     * Subfilter applied to this facet.
	     */
	    subFilter?: FacetSubfilter;
	    /**
	     * Optional date filter
	     */
	    dateFilter?: DateFilter;
	    /**
	     * Optional subscription filter
	     */
	    subscriptionFilter?: SubscriptionFilter;
	    /**
	     * Total number of available results (including the ones from results)
	     */
	    total?: number;
	    /**
	     * Facet is open; default = true
	     */
	    open?: boolean;
	    isSelected?: boolean;
	    /**
	     * Facet is visible
	     */
	    visible?: boolean;
	    /**
	     * Facet is read-only
	     */
	    readOnly?: boolean;
	    /**
	     * Facet is read-only
	     */
	    initialValue?: FacetGroupSettingValue;
	}

	export interface FacetListEntry {
	    /**
	     * Key that identifies this FacetListEntry.
	     */
	    key: string;
	    /**
	     * Name of the FacetListEntry
	     */
	    name: string;
	    /**
	     * Translated label of the FacetListEntry
	     */
	    label?: string;
	    /**
	     * How many search results can be expected if this
	     * facet list entry is selected.
	     */
	    count: number;
	    /**
	     * Is this FacetListEntry selected. Default: false.
	     */
	    selected?: boolean;
	}

	/**
	 * The FacetGroupSettingValue class acts as an interface, while also specifying all default values.
	 */
	export class FacetGroupSettingValue implements FacetFilter {
	    facetKey: string;
	    keys: string[];
	    operator?: string;
	    dateFilter?: DateFilter;
	    subscriptionFilter?: SubscriptionFilter;
	    facetType?: FacetType;
	}
	/**
	 * The FacetGroupSetting class acts as an interface, while also specifying all default values.
	 */
	export class FacetGroupSetting {
	    readOnly?: boolean;
	    /** Default values for initialValue are determined by class FacetGroupSettingValue */
	    initialValue?: FacetGroupSettingValue;
	    selectableKeys?: string[];
	}
	export interface FacetGroupsSettings {
	    [facetKey: string]: FacetGroupSetting;
	}
	export interface FacetSettings {
	    [factSheetType: string]: FacetGroupsSettings;
	}

	export interface SubscriptionFilter {
	    type: SubscriptionType;
	    role?: SubscriptionRole;
	}

	export interface CreateSubscriptionRole {
	    name: string;
	    description: string;
	    subscriptionType: SubscriptionType;
	    restrictToFactSheetTypes: string[];
	}
	export interface SubscriptionRole {
	    id: string;
	    name: string;
	    description?: string;
	    subscriptionType: SubscriptionType;
	    restrictToFactSheetTypes: string[];
	}
	export interface RequestSubscriptionsResponse {
	    subscriptionRoles: SubscriptionRole[];
	    pageInfo: PageInfo;
	}

	export class PageInfo {
	    hasNextPage: boolean;
	    hasPreviousPage: boolean;
	    startCursor?: string;
	    endCursor?: string;
	}

	export interface FacetSubfilter {
	    facetGroups?: FacetGroup[];
	    facetFilters?: FacetFilter[];
	    fullTextSearch?: string;
	    ids?: string[];
	}

	export interface Listener {
	    (data: any, isError?: boolean): void;
	}
	export class ReportLibMessenger {
	    private parentWindow;
	    private parentOrigin;
	    private listeners;
	    constructor();
	    /**
	     * Send a message to the parent
	     * @param {OutboundMessage} message
	     */
	    sendToParent<S, T>(_message: MessageFromReport<S>): void;
	    sendToParent<S, T>(_message: MessageFromReport<S>, _returnPromise: true): Promise<T>;
	    /**
	     * Call listener whenever a message with the given `id` (or otherwise any message)
	     * is received from the parent
	     */
	    registerListener(id: string, listener: Listener, callOnError?: boolean): void;
	    deRegisterListener(id?: string, listener?: Listener): void;
	    deRegisterAllListeners(): void;
	    listenOnce(id?: string): Promise<any>;
	    /**
	     * Handler for window message events
	     */
	    private messageListener(evt);
	    private callListeners(id, message);
	    private invokeCallback(id, callback);
	    private showError(message, title?);
	}

	/**
	 * Interface for messages received from the report
	 * @prop {String} action   Action to be executed by the parent
	 * @prop {Object} [params] Parameters for the action
	 * @prop {String} [id]     Unique identifier
	 */
	export interface MessageFromReport<T> {
	    action: string;
	    params?: T;
	    id?: string;
	}

	/**
	 * Interface for messages sent to the report
	 * @prop {Object}  data    Data received from Parent
	 * @prop {String}  id      Unique identifier of preceding outbound call
	 * @prop {Boolean} success Signifies whether a requested action succeeded
	 */
	export interface MessageToReport {
	    id?: String;
	    data?: any;
	    success?: Boolean;
	}

	export class ReportTablePopoverStyles {
	    top?: number | string;
	    width?: number;
	    arrowLeft?: number | string;
	}
	export class ReportTablePopoverParams {
	    factSheets: FactSheet[];
	    title?: string;
	    styles?: ReportTablePopoverStyles;
	    factSheetType?: string;
	    columns?: (string | ReportTableColumn)[];
	    maxRows?: number;
	}
	export class ReportLibTable {
	    private messenger;
	    private facetsConfigs;
	    showPopover(params: ReportTablePopoverParams): void;
	    hidePopover(): void;
	    setFacetsConfig(facetsConfig: ReportFacetsConfig, index: number): void;
	    private attributesPresentInConfig(config, requiredAttributes);
	}

	/**
	 * Describes the structure of a FactSheet response from the API.
	 */
	export interface FactSheet extends BaseFactSheet {
	    [key: string]: any;
	}

	export type FactSheetQualityState = 'APPROVED' | 'BROKEN' | 'DISABLED';
	export type FactSheetStatusState = 'ACTIVE' | 'ARCHIVED';
	export interface Completion {
	    /** Rounded to integer; floating `completion` also available here and below */
	    percentage: number;
	    sectionCompletions?: {
	        name: string;
	        percentage: number;
	        subsectionCompletions?: {
	            name: string;
	            percentage: number;
	        }[];
	    }[];
	}
	/**
	 * A minimal Fact Sheet object used in several places in the front-end for display
	 */
	export interface MinimalFactSheet {
	    id?: string;
	    type?: string;
	    displayName?: string;
	}
	/**
	 * Describes the structure of a Base FactSheet response from the API.
	 */
	export interface BaseFactSheet extends MinimalFactSheet {
	    id?: string;
	    rev?: number;
	    type?: string;
	    name?: string;
	    fullName?: string;
	    displayName?: string;
	    description?: string;
	    tags?: Tag[];
	    qualitySeal?: FactSheetQualityState;
	    naFields?: String[];
	    status?: FactSheetStatusState;
	    permissions?: PermissionList;
	    completion?: Completion;
	    subscriptions?: GraphqlConnection<FactSheetSubscription>;
	}

	export class GenericGraphqlConnection<T, E extends GraphqlConnectionEdge<T>> {
	    edges?: E[];
	    pageInfo?: PageInfo;
	    totalCount?: number;
	    permissions?: any;
	    t?: T;
	    constructor(T: new () => T);
	}
	export class GraphqlConnection<T> extends GenericGraphqlConnection<T, GraphqlConnectionEdge<T>> {
	}
	export interface GraphqlConnectionEdge<T> {
	    node: T;
	    cursor?: string;
	}

	export interface PermissionList {
	    self?: PermissionType[];
	    read?: string[];
	    create?: string[];
	    update?: string[];
	    delete?: string[];
	}

	export type PermissionType = 'READ' | 'CREATE' | 'UPDATE' | 'DELETE' | 'ARCHIVE';
	export type PermissionSet = Permission | Set<PermissionType> | PermissionType[];
	export class Permission {
	    set: Set<PermissionType>;
	    constructor(input?: PermissionSet);
	    /** custom toJSON() method for unit tests */
	    toJSON(): string;
	    /** custom toString() method for debug output */
	    toString(): string;
	    /** Check whether the given permissionType is part of this object's permission set */
	    permits(permissionType: PermissionType): boolean;
	    /** Create a new permission object containing this permission set + the given permission set */
	    union(permissionSet: PermissionSet): Permission;
	    /** Create a new permission object containing this permission set - the given permission set */
	    difference(permissionSet: PermissionSet): Permission;
	}
	export type PermissionTreeField = PermissionTree | PermissionTreeArray | Permission;
	export class PermissionTree extends BaseModel {
	    permissions: Permission;
	    fields: {
	        [field: string]: PermissionTreeField;
	    };
	    constructor(tree: PermissionTree);
	}
	export class PermissionTreeArray extends PermissionTree {
	    items: PermissionTree[];
	    constructor(tree: PermissionTreeArray);
	}

	export class BaseModel {
	    constructor(data?: any);
	}

	export type TagStatus = 'ACTIVE' | 'ARCHIVED';
	/**
	 * Represents a tag as it is provided by the GraphQL API.
	 *
	 * @export
	 * @interface Tag
	 */
	export interface Tag {
	    id: string;
	    name: string;
	    description?: string;
	    color?: string;
	    tagGroup?: TagGroup;
	    status?: TagStatus;
	    factSheetCount?: number;
	}

	export type TagGroupMode = 'SINGLE' | 'MULTIPLE';
	/**
	 * Represents a tag group as it is provided by the GraphQL API.
	 *
	 * @export
	 * @interface TagGroup
	 */
	export interface TagGroup {
	    id?: string;
	    name?: string;
	    shortName?: string;
	    description?: string;
	    mode?: TagGroupMode;
	    restrictToFactSheetTypes?: string[];
	    tagCount?: number;
	    mandatory?: boolean;
	}

	export enum FactSheetSubscriptionTypeOrder {
	    OBSERVER = 0,
	    RESPONSIBLE = 1,
	    ACCOUNTABLE = 2,
	}
	export interface FactSheetSubscriptionTypeSelect2 {
	    id: SubscriptionType;
	    text: string;
	}
	export interface FactSheetSubscription extends MyFactSheetSubscription {
	    id: string;
	    user: User;
	    type: SubscriptionType;
	    roles: SubscriptionRole[];
	    createdAt: Date;
	    factSheet?: BaseFactSheet;
	}
	export interface MyFactSheetSubscription {
	    id: string;
	    type: SubscriptionType;
	    roles: {
	        id: string;
	    }[];
	}

	export class User {
	    id?: string;
	    firstName?: string;
	    lastName?: string;
	    displayName?: string;
	    email?: string;
	    permission?: {
	        role?: MtmPermissionRole;
	        status?: MtmPermissionStatus;
	    };
	    constructor(user?: MtmUser | User);
	}

	export type MtmUserRole = 'SUPERADMIN' | 'SYSTEM' | 'APICLIENT' | 'ACCOUNTADMIN' | 'ACCOUNTUSER';
	export type MtmUserStatus = 'ACTIVE' | 'ARCHIVED';
	export interface MtmUser {
	    id?: string;
	    userName?: string;
	    email: string;
	    firstName: string;
	    lastName: string;
	    displayName?: string;
	    lastLogin?: Date;
	    account?: MtmAccount;
	    apiKey?: string;
	    feedKey?: string;
	    role?: MtmUserRole;
	    status?: MtmUserStatus;
	    crmTags?: string;
	    crmLink?: string;
	    links?: MtmLink[];
	    permissions?: MtmPermission[];
	    active?: boolean;
	}

	export type MtmPasswordPolicy = 'NORMAL' | 'STRICT';
	export interface MtmAccount {
	    id: string;
	    name: string;
	    customFeatures: MtmFeature[];
	    fromAddress?: string;
	    readonly links: MtmLink[];
	    responsibleUser?: MtmUser;
	    passwordPolicy: MtmPasswordPolicy;
	}

	export type MtmFeatureType = 'FUNCTIONAL' | 'QUOTA';
	export type MtmFeatureStatus = 'ENABLED' | 'DISABLED';
	export interface MtmFeature {
	    id: string;
	    name: string;
	    type: MtmFeatureType;
	    description: string;
	    status: MtmFeatureStatus;
	    quota: number;
	    roles: string[];
	    customized: boolean;
	}

	export interface MtmLink {
	    rel: string;
	    href: string;
	}

	export const ALL_MTM_PERMISSION_ROLES: MtmPermissionRole[];
	export type MtmPermissionRole = 'MEMBER' | 'ADMIN' | 'VIEWER' | 'CONTACT';
	export type MtmPermissionStatus = 'ACTIVE' | 'INVITED' | 'NOTINVITED' | 'ARCHIVED' | 'REQUESTED' | '!ACTIVE' | '!INVITED' | '!NOTINVITED' | '!ARCHIVED' | '!REQUESTED';
	export interface MtmPermission {
	    id: string;
	    user: MtmUser;
	    workspace: MtmWorkspace;
	    workspaceId: string;
	    role: MtmPermissionRole;
	    customerRoles?: string;
	    status: MtmPermissionStatus;
	    lastLogin: Date;
	    invitedByUser?: MtmUser;
	    reviewedByUser?: MtmUser;
	    ignoreBlacklist?: boolean;
	    readonly links: MtmLink[];
	    readonly active: boolean;
	}
	export interface MtmPermissionStat {
	    key: MtmPermissionStatus;
	    roleDetails: [{
	        count: number;
	        permissionRole: MtmPermissionRole;
	    }];
	    type: string;
	    value: string;
	}

	export type MtmWorkspaceStatus = 'ACTIVE' | 'BLOCKED';
	export type MtmWorkspaceType = 'LIVE' | 'DEMO';
	export interface MtmWorkspace {
	    id: string;
	    contract: MtmContract;
	    instance: MtmInstance;
	    name: string;
	    featureBundleId: string;
	    status: MtmWorkspaceStatus;
	    type: MtmWorkspaceType;
	    defaultRole: MtmPermissionRole;
	    comment: string;
	    createdAt: Date;
	    customFeatures: MtmFeature[];
	    readonly active: boolean;
	    readonly links: MtmLink[];
	}

	export type MtmContractType = 'REGULAR' | 'TRIAL';
	export type MtmContractStatus = 'ACTIVE' | 'BLOCKED';
	export interface MtmContract {
	    id: string;
	    featureBundleId: string;
	    startDate: Date;
	    type: MtmContractType;
	    status: MtmContractStatus;
	    comment: string;
	    customFeatures: MtmFeature[];
	    modulePurchases: MtmModulePurchase[];
	    account: MtmAccount;
	    application: MtmApplication;
	    readonly active: boolean;
	    readonly links: MtmLink[];
	    readonly displayName: string;
	}

	export interface MtmApplication {
	    name: string;
	    type: string;
	}

	export interface MtmModulePurchase {
	    id: string;
	    purchase: number;
	}

	export interface MtmInstance {
	    id: string;
	    name: string;
	    url: string;
	    identityManagement?: MtmIdentityManagement;
	    isDefault: boolean;
	    isPrimary: boolean;
	    entityId: string;
	    application: MtmApplication;
	    resourceServerKey: string;
	    description?: string;
	    scopes: string[];
	    resourceServerSecret: string;
	    account?: MtmAccount;
	    links: MtmLink[];
	    thirdParty: boolean;
	}

	export type SSOIdentityManagementType = 'FULLY_EXTERNAL' | 'MTM_BASED_ROLES';
	export type NoSSOIdentityManagementType = 'FULLY_MTM_BASED';
	export type MtmIdentityManagement = SSOIdentityManagementType | NoSSOIdentityManagementType;
	export const SSOIdentityManagement: {
	    fullyExternal: MtmIdentityManagement;
	    mtmBasedRoles: MtmIdentityManagement;
	};
	export const NoSSOIdentityManagement: {
	    fullyMtmBased: MtmIdentityManagement;
	};
	export const MtmIdentityManagement: {
	    fullyExternal: MtmIdentityManagement;
	    mtmBasedRoles: MtmIdentityManagement;
	} & {
	    fullyMtmBased: MtmIdentityManagement;
	};

}